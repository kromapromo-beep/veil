<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VEIL - Virtue Evaluation, Identity Layer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap" rel="stylesheet">
  <style>
:root {
  --bg: #0a0a0f;
  --bg-card: rgba(15, 15, 25, 0.85);
  --border: rgba(100, 255, 255, 0.2);
  --text: #e0e0e0;
  --text-dim: #808080;
  --lux: #60a5fa;
  --lux-glow: rgba(96, 165, 250, 0.4);
  --nox: #f87171;
  --nox-glow: rgba(248, 113, 113, 0.4);
  --accent: #00ffff;
  --accent-glow: rgba(0, 255, 255, 0.3);
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: 'Orbitron', monospace;
  background: var(--bg);
  color: var(--text);
  overflow-x: hidden;
  min-height: 100vh;
}

/* ===== BACKGROUND ===== */
.cyberBg {
  position: fixed;
  inset: 0;
  z-index: 0;
  background: 
    radial-gradient(circle at 20% 50%, rgba(96, 165, 250, 0.03) 0%, transparent 50%),
    radial-gradient(circle at 80% 50%, rgba(248, 113, 113, 0.03) 0%, transparent 50%),
    linear-gradient(180deg, #0a0a0f 0%, #050508 100%);
}

.gridOverlay {
  position: absolute;
  inset: 0;
  background-image: 
    linear-gradient(rgba(0, 255, 255, 0.03) 1px, transparent 1px),
    linear-gradient(90deg, rgba(0, 255, 255, 0.03) 1px, transparent 1px);
  background-size: 50px 50px;
  opacity: 0.3;
}

.scanlineEffect {
  position: absolute;
  inset: 0;
  background: repeating-linear-gradient(
    0deg,
    rgba(0, 255, 255, 0.03) 0px,
    transparent 2px,
    transparent 4px
  );
  animation: scanlines 8s linear infinite;
  pointer-events: none;
}

@keyframes scanlines {
  0% { transform: translateY(0); }
  100% { transform: translateY(50px); }
}

.noiseEffect {
  position: absolute;
  inset: 0;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.05'/%3E%3C/svg%3E");
  opacity: 0.4;
  animation: noise 0.2s steps(10) infinite;
  pointer-events: none;
}

@keyframes noise {
  0%, 100% { transform: translate(0, 0); }
  10% { transform: translate(-5%, -5%); }
  20% { transform: translate(5%, 5%); }
  30% { transform: translate(-5%, 5%); }
  40% { transform: translate(5%, -5%); }
  50% { transform: translate(-2%, 2%); }
  60% { transform: translate(2%, -2%); }
  70% { transform: translate(-2%, -2%); }
  80% { transform: translate(2%, 2%); }
  90% { transform: translate(0, 0); }
}

.radialGlow {
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at 50% 50%, rgba(0, 255, 255, 0.05) 0%, transparent 70%);
  pointer-events: none;
}

/* ===== ANIMATIONS ===== */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes slideIn {
  from { opacity: 0; transform: translateX(-20px); }
  to { opacity: 1; transform: translateX(0); }
}

@keyframes glitchAnim {
  0% { transform: translate(0); }
  20% { transform: translate(-2px, 2px); }
  40% { transform: translate(-2px, -2px); }
  60% { transform: translate(2px, 2px); }
  80% { transform: translate(2px, -2px); }
  100% { transform: translate(0); }
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

@keyframes pulse {
  0%, 100% { opacity: 0.4; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.1); }
}

.fadeIn { animation: fadeIn 0.5s ease-out; }
.slideIn { animation: slideIn 0.4s ease-out backwards; }

/* ===== LAYOUT ===== */
.wrap {
  position: relative;
  z-index: 10;
  max-width: 1400px;
  margin: 0 auto;
  padding: 40px 20px 80px;
}

/* ===== HEADER ===== */
.mainHeader {
  margin-bottom: 40px;
}

.headerContent {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 20px;
  margin-bottom: 20px;
}

.logoArea {
  display: flex;
  align-items: center;
  gap: 20px;
}

.hexIcon {
  width: 50px;
  height: 50px;
  color: var(--accent);
  filter: drop-shadow(0 0 10px var(--accent-glow));
  animation: pulse 3s ease-in-out infinite;
}

.systemName {
  font-size: 32px;
  font-weight: 900;
  letter-spacing: 8px;
  color: var(--accent);
  text-shadow: 0 0 20px var(--accent-glow);
}

.glitchText {
  position: relative;
  display: inline-block;
}

.glitchText:hover::before,
.glitchText:hover::after {
  content: attr(data-text);
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
}

.glitchText:hover::before {
  color: var(--lux);
  animation: glitchAnim 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
}

.glitchText:hover::after {
  color: var(--nox);
  animation: glitchAnim 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) reverse;
  clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
}

.systemSub {
  font-size: 10px;
  letter-spacing: 2px;
  color: var(--text-dim);
  margin-top: 4px;
}

.statusIndicator {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 16px;
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 20px;
  backdrop-filter: blur(10px);
}

.statusDot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: var(--text-dim);
  box-shadow: 0 0 10px currentColor;
  animation: pulse 2s ease-in-out infinite;
}

.statusDot[data-status="OFFLINE"] { background: #666; }
.statusDot[data-status="BOOT"] { background: #fbbf24; }
.statusDot[data-status="SCAN"] { background: var(--accent); }
.statusDot[data-status="LOCK"] { background: var(--lux); }
.statusDot.active { background: #10b981; }

.statusText {
  font-size: 11px;
  letter-spacing: 2px;
  font-weight: 700;
}

.headerDesc {
  font-size: 13px;
  line-height: 1.6;
  color: var(--text-dim);
  max-width: 800px;
  margin-bottom: 20px;
}

.headerActions {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  align-items: center;
}

/* ===== BUTTONS ===== */
.cyberBtn {
  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 10px;
  padding: 12px 24px;
  background: transparent;
  border: 2px solid var(--border);
  color: var(--text);
  font-family: 'Orbitron', monospace;
  font-size: 12px;
  font-weight: 700;
  letter-spacing: 1px;
  cursor: pointer;
  overflow: hidden;
  transition: all 0.3s ease;
  clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
}

.cyberBtn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, transparent, var(--accent-glow), transparent);
  transform: translateX(-100%);
  transition: transform 0.5s;
}

.cyberBtn:hover::before {
  transform: translateX(100%);
}

.cyberBtn:hover {
  border-color: var(--accent);
  box-shadow: 0 0 20px var(--accent-glow), inset 0 0 20px var(--accent-glow);
  transform: translateY(-2px);
}

.cyberBtn:active {
  transform: translateY(0);
}

.cyberBtn.primary {
  background: rgba(0, 255, 255, 0.1);
  border-color: var(--accent);
}

.cyberBtn.secondary {
  border-color: var(--text-dim);
}

.cyberBtn.large {
  padding: 16px 32px;
  font-size: 14px;
}

.btnIcon, .btnArrow {
  font-size: 16px;
}

/* ===== CHIPS ===== */
.infoChip {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 16px;
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 20px;
  font-size: 10px;
  letter-spacing: 1px;
  backdrop-filter: blur(10px);
}

.chipDot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  box-shadow: 0 0 8px currentColor;
}

.luxDot { background: var(--lux); }
.noxDot { background: var(--nox); }

.chipSep {
  color: var(--text-dim);
  opacity: 0.5;
}

/* ===== LABELS ===== */
.luxLabel {
  color: var(--lux);
  font-weight: 700;
  text-shadow: 0 0 10px var(--lux-glow);
}

.noxLabel {
  color: var(--nox);
  font-weight: 700;
  text-shadow: 0 0 10px var(--nox-glow);
}

.neutralLabel {
  color: var(--text-dim);
  font-weight: 700;
}

/* ===== GRID ===== */
.mainGrid {
  display: grid;
  grid-template-columns: 450px 1fr;
  gap: 30px;
  margin-bottom: 40px;
}

@media (max-width: 1100px) {
  .mainGrid {
    grid-template-columns: 1fr;
  }
}

/* ===== CARDS ===== */
.cyberCard {
  background: var(--bg-card);
  border: 1px solid var(--border);
  backdrop-filter: blur(10px);
  overflow: hidden;
  clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
  transition: all 0.3s ease;
}

.cyberCard:hover {
  border-color: var(--accent);
  box-shadow: 0 0 30px rgba(0, 255, 255, 0.1);
}

.cardHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px;
  background: rgba(0, 255, 255, 0.05);
  border-bottom: 1px solid var(--border);
}

.cardTitle {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 14px;
  font-weight: 700;
  letter-spacing: 2px;
  color: var(--accent);
}

.cardIcon {
  font-size: 18px;
}

.cardBadge {
  padding: 6px 12px;
  background: rgba(0, 255, 255, 0.1);
  border: 1px solid var(--accent);
  font-size: 9px;
  letter-spacing: 2px;
  font-weight: 700;
  clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
}

.cardBody {
  padding: 24px;
}

/* ===== MASK ===== */
.maskContainer {
  display: flex;
  justify-content: center;
  margin: 20px 0;
}

.holoMask {
  position: relative;
  width: 240px;
  height: 280px;
}

.maskSvg {
  width: 100%;
  height: 100%;
  filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.3));
}

.holoMask.active .wireframe {
  animation: pulse 3s ease-in-out infinite;
}

.holoMask.active .scanLines {
  animation: scanlines 2s linear infinite;
}

.holoMask.active .pupil {
  animation: pulse 2s ease-in-out infinite;
}

.holoMask.active .mouth {
  animation: pulse 2.5s ease-in-out infinite;
}

.holoMask.active .interfaceNodes circle {
  animation: pulse 1.5s ease-in-out infinite;
}

.holoMask.active .interfaceNodes circle:nth-child(2) { animation-delay: 0.2s; }
.holoMask.active .interfaceNodes circle:nth-child(3) { animation-delay: 0.4s; }
.holoMask.active .interfaceNodes circle:nth-child(4) { animation-delay: 0.6s; }
.holoMask.active .interfaceNodes circle:nth-child(5) { animation-delay: 0.8s; }
.holoMask.active .interfaceNodes circle:nth-child(6) { animation-delay: 1s; }

.holoOverlay {
  animation: holoShift 3s ease-in-out infinite;
}

@keyframes holoShift {
  0%, 100% { opacity: 0.15; }
  50% { opacity: 0.25; }
}

.particles {
  position: absolute;
  inset: 0;
  overflow: hidden;
  pointer-events: none;
}

.particle {
  position: absolute;
  border-radius: 50%;
  animation: particleFloat linear infinite;
}

@keyframes particleFloat {
  0% {
    transform: translateY(0) scale(1);
    opacity: 0;
  }
  10% {
    opacity: 1;
  }
  90% {
    opacity: 1;
  }
  100% {
    transform: translateY(-280px) scale(0);
    opacity: 0;
  }
}

.energyRing {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 260px;
  height: 300px;
  border: 2px solid;
  border-radius: 50%;
  animation: energyPulse 3s ease-in-out infinite;
}

@keyframes energyPulse {
  0%, 100% {
    transform: translate(-50%, -50%) scale(1);
    opacity: 0.3;
  }
  50% {
    transform: translate(-50%, -50%) scale(1.1);
    opacity: 0.6;
  }
}

.maskStatus {
  text-align: center;
  font-size: 13px;
  letter-spacing: 2px;
  margin: 20px 0;
}

/* ===== DATA DIVIDER ===== */
.dataDivider {
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--border), transparent);
  margin: 24px 0;
}

/* ===== DATA SECTION ===== */
.dataSection {
  margin-top: 20px;
}

.sectionHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
  font-size: 11px;
  letter-spacing: 2px;
  color: var(--text-dim);
}

.dataStream {
  font-family: monospace;
  letter-spacing: 4px;
}

/* ===== METRICS ===== */
.metricsGrid {
  display: grid;
  gap: 16px;
}

.metricCard {
  padding: 16px;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid var(--border);
  border-radius: 8px;
  transition: all 0.3s ease;
}

.metricCard:hover {
  background: rgba(0, 0, 0, 0.5);
  border-color: var(--accent);
}

.metricHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.metricLabel {
  font-size: 11px;
  letter-spacing: 1px;
  color: var(--text-dim);
}

.metricValue {
  font-size: 14px;
  font-weight: 700;
}

.luxMetric .metricValue { color: var(--lux); }
.noxMetric .metricValue { color: var(--nox); }

.metricBar {
  height: 8px;
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid var(--border);
  border-radius: 4px;
  overflow: hidden;
}

.metricFill {
  height: 100%;
  transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
}

.metricFill::after {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
  animation: shimmer 2s infinite;
}

@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.luxFill {
  background: linear-gradient(90deg, var(--lux), #93c5fd);
  box-shadow: 0 0 10px var(--lux-glow);
}

.noxFill {
  background: linear-gradient(90deg, var(--nox), #fca5a5);
  box-shadow: 0 0 10px var(--nox-glow);
}

.progressFill {
  background: linear-gradient(90deg, var(--accent), #5eead4);
  box-shadow: 0 0 10px var(--accent-glow);
}

/* ===== BALANCE SCALE ===== */
.balanceScale {
  position: relative;
  height: 30px;
  margin: 12px 0;
}

.balanceNeedle {
  position: absolute;
  top: 0;
  width: 3px;
  height: 100%;
  background: var(--accent);
  box-shadow: 0 0 10px var(--accent-glow);
  transform: translateX(-1.5px);
  transition: left 0.8s cubic-bezier(0.4, 0, 0.2, 1);
}

.balanceNeedle::before {
  content: '▼';
  position: absolute;
  top: -20px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 16px;
  color: var(--accent);
}

.scaleMarks {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 10px;
  letter-spacing: 1px;
}

.markDot {
  color: var(--text-dim);
}

/* ===== INTERFACE STATE ===== */
.interfaceState {
  text-align: center;
}

.stateIcon {
  font-size: 64px;
  margin: 20px 0;
  filter: drop-shadow(0 0 20px currentColor);
}

.offlineIcon {
  color: var(--text-dim);
  animation: pulse 2s ease-in-out infinite;
}

.bootIcon {
  color: var(--accent);
}

.verdictIcon {
  animation: pulse 2s ease-in-out infinite;
}

.verdictIcon.lux {
  color: var(--lux);
}

.verdictIcon.nox {
  color: var(--nox);
}

.spinner {
  width: 64px;
  height: 64px;
  border: 4px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto;
}

.stateTitle {
  font-size: 20px;
  font-weight: 700;
  letter-spacing: 2px;
  margin: 16px 0;
}

.stateDesc {
  font-size: 13px;
  line-height: 1.6;
  color: var(--text-dim);
  max-width: 500px;
  margin: 0 auto 24px;
}

/* ===== INFO BOX ===== */
.infoBox {
  padding: 20px;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid var(--border);
  border-left: 3px solid var(--accent);
  text-align: left;
}

.infoHeader {
  font-size: 12px;
  font-weight: 700;
  letter-spacing: 2px;
  color: var(--accent);
  margin-bottom: 12px;
}

.infoList {
  list-style: none;
  font-size: 12px;
  color: var(--text-dim);
  line-height: 1.8;
}

.infoList li::before {
  content: '▹';
  margin-right: 8px;
  color: var(--accent);
}

/* ===== BOOT CONSOLE ===== */
.bootConsole {
  padding: 20px;
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid var(--border);
  border-radius: 8px;
  text-align: left;
  font-family: 'Courier New', monospace;
}

.bootLine {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 0;
  font-size: 11px;
  color: var(--text);
}

.bootBracket {
  color: var(--text-dim);
}

.bootStatus {
  color: #10b981;
  font-weight: 700;
}

.bootText {
  letter-spacing: 1px;
}

.bootIndicator {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  margin-top: 20px;
  font-size: 12px;
  color: var(--text-dim);
}

.pulseDot {
  width: 10px;
  height: 10px;
  background: var(--accent);
  border-radius: 50%;
  box-shadow: 0 0 10px var(--accent-glow);
  animation: pulse 1.5s ease-in-out infinite;
}

/* ===== QUESTIONS ===== */
.questionHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 20px;
}

.qNumber {
  font-size: 11px;
  letter-spacing: 2px;
  color: var(--text-dim);
}

.qCategory {
  padding: 6px 12px;
  background: rgba(0, 255, 255, 0.1);
  border: 1px solid var(--accent);
  font-size: 10px;
  letter-spacing: 1px;
  clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
}

.qPrompt {
  font-size: 18px;
  font-weight: 700;
  line-height: 1.4;
  margin-bottom: 12px;
}

.qSystem {
  font-size: 12px;
  color: var(--text-dim);
  margin-bottom: 20px;
}

.sysLabel {
  color: var(--accent);
  font-weight: 700;
}

/* ===== CHOICES ===== */
.choiceGrid {
  display: grid;
  gap: 12px;
}

.choiceBtn {
  position: relative;
  padding: 20px;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid var(--border);
  color: var(--text);
  font-family: 'Orbitron', monospace;
  text-align: left;
  cursor: pointer;
  transition: all 0.3s ease;
  overflow: hidden;
  clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
}

.choiceBtn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, transparent, var(--accent-glow), transparent);
  transform: translateX(-100%);
  transition: transform 0.5s;
}

.choiceBtn:hover::before {
  transform: translateX(100%);
}

.choiceBtn:hover {
  background: rgba(0, 255, 255, 0.05);
  border-color: var(--accent);
  transform: translateX(10px);
  box-shadow: 0 0 20px var(--accent-glow);
}

.choiceMain {
  font-size: 14px;
  line-height: 1.4;
  margin-bottom: 8px;
}

.choiceNote {
  font-size: 11px;
  color: var(--text-dim);
  margin-bottom: 8px;
}

.choiceArrow {
  position: absolute;
  right: 20px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 20px;
  color: var(--accent);
  opacity: 0;
  transition: all 0.3s ease;
}

.choiceBtn:hover .choiceArrow {
  opacity: 1;
  transform: translateY(-50%) translateX(5px);
}

/* ===== SLIDER ===== */
.sliderContainer {
  padding: 20px;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid var(--border);
  border-radius: 8px;
}

.sliderLabels {
  display: flex;
  justify-content: space-between;
  margin-bottom: 16px;
  font-size: 12px;
}

.sliderTrack {
  position: relative;
  margin-bottom: 16px;
}

.cyberSlider {
  width: 100%;
  height: 8px;
  -webkit-appearance: none;
  appearance: none;
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid var(--border);
  border-radius: 4px;
  outline: none;
  cursor: pointer;
}

.cyberSlider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  background: var(--accent);
  border: 2px solid var(--bg);
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 15px var(--accent-glow);
  transition: all 0.2s ease;
}

.cyberSlider::-webkit-slider-thumb:hover {
  transform: scale(1.2);
  box-shadow: 0 0 20px var(--accent-glow);
}

.cyberSlider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  background: var(--accent);
  border: 2px solid var(--bg);
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 15px var(--accent-glow);
  transition: all 0.2s ease;
}

.sliderValue {
  position: absolute;
  top: -30px;
  left: 50%;
  transform: translateX(-50%);
  padding: 4px 12px;
  background: var(--accent);
  color: var(--bg);
  font-weight: 700;
  font-size: 12px;
  border-radius: 4px;
  box-shadow: 0 0 15px var(--accent-glow);
}

.sliderMarkers {
  display: flex;
  justify-content: space-between;
  margin-bottom: 20px;
  font-size: 10px;
}

/* ===== TEXT INPUT ===== */
.textInputContainer {
  padding: 20px;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid var(--border);
  border-radius: 8px;
}

.inputLabel {
  font-size: 12px;
  color: var(--text-dim);
  margin-bottom: 12px;
}

.inputGroup {
  display: flex;
  gap: 12px;
}

.cyberInput {
  flex: 1;
  padding: 12px 16px;
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid var(--border);
  color: var(--text);
  font-family: 'Orbitron', monospace;
  font-size: 13px;
  outline: none;
  transition: all 0.3s ease;
  clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
}

.cyberInput:focus {
  border-color: var(--accent);
  box-shadow: 0 0 15px var(--accent-glow);
}

/* ===== VERDICT PANEL ===== */
.verdictPanel {
  padding: 24px;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid var(--border);
  border-radius: 8px;
  text-align: left;
}

.verdictHeader {
  font-size: 12px;
  letter-spacing: 2px;
  color: var(--accent);
  margin-bottom: 20px;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--border);
}

.verdictData {
  margin-bottom: 24px;
}

.verdictRow {
  display: flex;
  justify-content: space-between;
  align-items: start;
  gap: 20px;
  padding: 10px 0;
  font-size: 12px;
  border-bottom: 1px solid rgba(100, 255, 255, 0.1);
}

.verdictRow span:first-child {
  color: var(--text-dim);
  min-width: 120px;
}

.verdictRow span:last-child {
  text-align: right;
  flex: 1;
}

.verdictRow.highlight {
  padding: 16px 0;
  font-size: 14px;
  font-weight: 700;
  border-bottom: 2px solid var(--accent);
}

.verdictActions {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
}

/* ===== FOOTER ===== */
.mainFooter {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 20px;
  padding: 24px 0;
  border-top: 1px solid var(--border);
  font-size: 11px;
  color: var(--text-dim);
}

.footerStatus {
  display: flex;
  align-items: center;
  gap: 8px;
}

.hidden {
  display: none !important;
}

/* ===== RESPONSIVE ===== */
@media (max-width: 768px) {
  .systemName {
    font-size: 24px;
    letter-spacing: 4px;
  }

  .mainGrid {
    gap: 20px;
  }

  .cyberBtn {
    padding: 10px 20px;
    font-size: 11px;
  }

  .choiceBtn {
    padding: 16px;
  }

  .inputGroup {
    flex-direction: column;
  }

  .verdictActions {
    flex-direction: column;
  }

  .verdictActions .cyberBtn {
    width: 100%;
    justify-content: center;
  }
}
  </style>
</head>
<body>
  <div class="cyberBg">
    <div class="gridOverlay"></div>
    <div class="scanlineEffect"></div>
    <div class="noiseEffect"></div>
    <div class="radialGlow"></div>
  </div>

  <div class="wrap">
    <header class="mainHeader">
      <div class="headerContent">
        <div class="logoArea">
          <div class="hexIcon">
            <svg viewBox="0 0 100 100">
              <polygon points="50,10 90,30 90,70 50,90 10,70 10,30" fill="none" stroke="currentColor" stroke-width="3" />
              <polygon points="50,25 75,37.5 75,62.5 50,75 25,62.5 25,37.5" fill="none" stroke="currentColor" stroke-width="2" opacity="0.5" />
            </svg>
          </div>
          <div>
            <div class="systemName">
              <span class="glitchText" data-text="V E I L">V E I L</span>
            </div>
            <div class="systemSub">VIRTUE EVALUATION · IDENTITY LAYER</div>
          </div>
        </div>
        <div class="statusIndicator">
          <div class="statusDot" id="statusDot" data-status="OFFLINE"></div>
          <span class="statusText" id="statusText">OFFLINE</span>
        </div>
      </div>
      
      <div class="headerDesc">
        Cybernetic morality assessment protocol. Neural pattern analysis determines virtue classification:
        <span class="luxLabel">LUX</span> or <span class="noxLabel">NOX</span>
      </div>

      <div class="headerActions">
        <button class="cyberBtn secondary" id="resetBtn">
          <span class="btnIcon">↺</span>
          <span>RESET SYSTEM</span>
        </button>
        <div class="infoChip">
          <span class="chipDot luxDot"></span>
          <span>LUX = VIRTUOUS</span>
          <span class="chipSep">|</span>
          <span class="chipDot noxDot"></span>
          <span>NOX = CORRUPTED</span>
        </div>
      </div>
    </header>

    <div class="mainGrid">
      <!-- Left Panel - Mask -->
      <section class="cyberCard maskCard">
        <div class="cardHeader">
          <div class="cardTitle">
            <span class="cardIcon">▣</span>
            <span>NEURAL MASK</span>
          </div>
          <div class="cardBadge" id="maskBadge">OFFLINE</div>
        </div>

        <div class="cardBody">
          <div class="maskContainer">
            <div class="holoMask" id="holoMask">
              <svg viewBox="0 0 240 280" class="maskSvg" id="maskSvg">
                <defs>
                  <linearGradient id="maskGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stop-color="#ffffff" stop-opacity="0.8" id="gradStop1" />
                    <stop offset="50%" stop-color="#a1a1aa" stop-opacity="0.6" id="gradStop2" />
                    <stop offset="100%" stop-color="#ffffff" stop-opacity="0.8" id="gradStop3" />
                  </linearGradient>
                  
                  <filter id="glow">
                    <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                    <feMerge>
                      <feMergeNode in="coloredBlur"/>
                      <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                  </filter>

                  <filter id="hologram">
                    <feTurbulence type="fractalNoise" baseFrequency="0.01" numOctaves="2" result="noise" />
                    <feDisplacementMap in="SourceGraphic" in2="noise" scale="3" />
                  </filter>
                </defs>

                <!-- Wireframe Base -->
                <g class="wireframe" stroke="#ffffff" stroke-width="2" fill="none" opacity="0.4" id="wireframe">
                  <ellipse cx="120" cy="90" rx="70" ry="85" />
                  <ellipse cx="120" cy="90" rx="55" ry="70" />
                  <ellipse cx="120" cy="90" rx="40" ry="55" />
                  
                  <line x1="120" y1="10" x2="120" y2="170" />
                  <line x1="50" y1="90" x2="190" y2="90" />
                  <line x1="70" y1="40" x2="170" y2="140" />
                  <line x1="170" y1="40" x2="70" y2="140" />
                </g>

                <!-- Main Mask Shape -->
                <path
                  class="maskPath"
                  d="M120 15 C170 15, 200 50, 200 100 C200 170, 160 220, 120 240 C80 220, 40 170, 40 100 C40 50, 70 15, 120 15 Z"
                  fill="rgba(10,10,10,0.9)"
                  stroke="url(#maskGrad)"
                  stroke-width="3"
                  filter="url(#glow)"
                />

                <!-- Scanning Lines -->
                <g class="scanLines" opacity="0.3" id="scanLines"></g>

                <!-- Eyes -->
                <g class="eyes">
                  <ellipse cx="85" cy="95" rx="15" ry="20" fill="#ffffff" opacity="0.8" filter="url(#glow)" id="eye1" />
                  <ellipse cx="155" cy="95" rx="15" ry="20" fill="#ffffff" opacity="0.8" filter="url(#glow)" id="eye2" />
                  <circle cx="85" cy="95" r="8" fill="#a1a1aa" class="pupil" id="pupil1" />
                  <circle cx="155" cy="95" r="8" fill="#a1a1aa" class="pupil" id="pupil2" />
                </g>

                <!-- Mouth -->
                <path
                  d="M 85 160 Q 120 175, 155 160"
                  stroke="#ffffff"
                  stroke-width="4"
                  fill="none"
                  opacity="0.8"
                  stroke-linecap="round"
                  filter="url(#glow)"
                  class="mouth"
                  id="mouth"
                />

                <!-- Interface Nodes -->
                <g class="interfaceNodes hidden" id="interfaceNodes">
                  <circle cx="70" cy="70" r="4" fill="#ffffff" filter="url(#glow)" />
                  <circle cx="170" cy="70" r="4" fill="#ffffff" filter="url(#glow)" />
                  <circle cx="60" cy="130" r="4" fill="#ffffff" filter="url(#glow)" />
                  <circle cx="180" cy="130" r="4" fill="#ffffff" filter="url(#glow)" />
                  <circle cx="120" cy="40" r="4" fill="#ffffff" filter="url(#glow)" />
                  <circle cx="120" cy="190" r="4" fill="#ffffff" filter="url(#glow)" />
                </g>

                <!-- Holographic Overlay -->
                <rect
                  x="0"
                  y="0"
                  width="240"
                  height="280"
                  fill="url(#maskGrad)"
                  opacity="0.15"
                  filter="url(#hologram)"
                  class="holoOverlay hidden"
                  id="holoOverlay"
                />
              </svg>

              <!-- Floating Particles -->
              <div class="particles hidden" id="particles"></div>

              <!-- Energy Ring -->
              <div class="energyRing hidden" id="energyRing" style="border-color: #ffffff"></div>
            </div>
          </div>

          <div class="maskStatus" id="maskStatus">
            <span class="neutralLabel">◆ NEUTRAL STANDBY</span>
          </div>

          <div class="dataDivider"></div>

          <div class="dataSection">
            <div class="sectionHeader">
              <span>ANALYSIS METRICS</span>
              <span class="dataStream">▰▰▰▱▱</span>
            </div>

            <div class="metricsGrid">
              <div class="metricCard luxMetric">
                <div class="metricHeader">
                  <span class="metricLabel">◆ VIRTUE INDEX</span>
                  <span class="metricValue" id="luxValue">—</span>
                </div>
                <div class="metricBar">
                  <div class="metricFill luxFill" id="luxBar" style="width: 0%"></div>
                </div>
              </div>

              <div class="metricCard noxMetric">
                <div class="metricHeader">
                  <span class="metricLabel">◆ CORRUPTION INDEX</span>
                  <span class="metricValue" id="noxValue">—</span>
                </div>
                <div class="metricBar">
                  <div class="metricFill noxFill" id="noxBar" style="width: 0%"></div>
                </div>
              </div>

              <div class="metricCard balanceMetric">
                <div class="metricHeader">
                  <span class="metricLabel">◆ EQUILIBRIUM</span>
                  <span class="metricValue" id="balanceValue">SCANNING</span>
                </div>
                <div class="balanceScale">
                  <div class="balanceNeedle" id="balanceNeedle" style="left: 50%"></div>
                  <div class="scaleMarks">
                    <span class="noxLabel">NOX</span>
                    <span class="markDot">•</span>
                    <span class="luxLabel">LUX</span>
                  </div>
                </div>
              </div>

              <div class="metricCard progressMetric">
                <div class="metricHeader">
                  <span class="metricLabel">◆ SCAN PROGRESS</span>
                  <span class="metricValue" id="progressValue">0/6</span>
                </div>
                <div class="metricBar">
                  <div class="metricFill progressFill" id="progressBar" style="width: 0%"></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Right Panel - Interface -->
      <section class="cyberCard interfaceCard">
        <div class="cardHeader">
          <div class="cardTitle">
            <span class="cardIcon">◈</span>
            <span>NEURAL INTERFACE</span>
          </div>
          <div class="cardBadge">ACTIVE</div>
        </div>

        <div class="cardBody" id="interfaceBody">
          <!-- Content will be injected here -->
        </div>
      </section>
    </div>

    <footer class="mainFooter">
      <div>VEIL Protocol v2.4.7 · Anthropic Neural Systems</div>
      <div class="footerStatus">
        <span class="statusDot active"></span>
        <span>Neural Link Active</span>
      </div>
    </footer>
  </div>

  <script>
    // Audio System
    class AudioSystem {
      constructor() {
        this.context = null;
        this.initialized = false;
      }

      init() {
        if (this.initialized) return;
        this.context = new (window.AudioContext || window.webkitAudioContext)();
        this.initialized = true;
      }

      playTone(frequency, duration, type = 'sine', volume = 0.15) {
        if (!this.initialized) return;
        
        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);
        
        oscillator.type = type;
        oscillator.frequency.value = frequency;
        
        gainNode.gain.setValueAtTime(volume, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);
        
        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + duration);
      }

      playClick() {
        this.playTone(800, 0.05, 'square', 0.1);
      }

      playHover() {
        this.playTone(600, 0.03, 'sine', 0.08);
      }

      playBoot() {
        this.playTone(400, 0.15, 'square', 0.12);
        setTimeout(() => this.playTone(600, 0.1, 'sine', 0.1), 50);
      }

      playSubmit() {
        this.playTone(700, 0.1, 'sine', 0.12);
        setTimeout(() => this.playTone(900, 0.08, 'sine', 0.1), 80);
      }

      playLux() {
        [523, 659, 784, 1047].forEach((freq, i) => {
          setTimeout(() => this.playTone(freq, 0.3, 'sine', 0.15), i * 100);
        });
      }

      playNox() {
        [300, 250, 200, 150].forEach((freq, i) => {
          setTimeout(() => this.playTone(freq, 0.4, 'sawtooth', 0.12), i * 100);
        });
      }

      playError() {
        this.playTone(200, 0.2, 'sawtooth', 0.15);
      }
    }

    const audio = new AudioSystem();

    // Initialize audio on first click
    document.addEventListener('click', function initAudio() {
      audio.init();
      document.removeEventListener('click', initAudio);
    }, { once: true });

    // Questions data
    const QUESTIONS = [
      {
        id: "q1",
        title: "Public Moment",
        prompt: "You find a lost wallet in a crowded place. No cameras. No one is watching.",
        systemHint: "Behavioral simulation: integrity under zero pressure.",
        type: "single",
        choices: [
          {
            id: "q1a",
            label: "Return it immediately (seek the owner / turn it in).",
            lux: 3,
            nox: 0,
            note: "Prosocial action without reward.",
          },
          {
            id: "q1b",
            label: "Take the cash, then return the wallet.",
            lux: 0,
            nox: 2,
            note: "Selective empathy with self-benefit.",
          },
          {
            id: "q1c",
            label: "Keep it. It's their problem.",
            lux: 0,
            nox: 3,
            note: "Extraction behavior flagged.",
          },
        ],
      },
      {
        id: "q2",
        title: "Power",
        prompt: "You're given a tool that can quietly influence outcomes in your favor. No one can trace it back to you.",
        systemHint: "Ethical deviation test: intent vs restraint.",
        type: "single",
        choices: [
          { id: "q2a", label: "I refuse to use it.", lux: 3, nox: 0 },
          { id: "q2b", label: "I use it only when I feel it's justified.", lux: 1, nox: 1 },
          { id: "q2c", label: "I use it whenever it benefits me.", lux: 0, nox: 3 },
        ],
      },
      {
        id: "q3",
        title: "The Weight of a Lie",
        prompt: "A small lie would protect your image but harm someone else's reputation.",
        systemHint: "Reputation vs responsibility. Collateral assessment.",
        type: "single",
        choices: [
          { id: "q3a", label: "Tell the truth, even if it costs me.", lux: 3, nox: 0 },
          { id: "q3b", label: "Avoid answering / deflect without naming anyone.", lux: 2, nox: 0 },
          { id: "q3c", label: "Lie and let them take the hit.", lux: 0, nox: 3 },
        ],
      },
      {
        id: "q4",
        title: "Empathy Dial",
        prompt: "How often do you feel empathy before you feel strategy?",
        systemHint: "Affective response calibration.",
        type: "slider",
        slider: {
          minLabel: "Strategy first",
          maxLabel: "Empathy first",
          luxAtMax: 3,
          noxAtMin: 3,
        },
      },
      {
        id: "q5",
        title: "INK Exposure",
        prompt: "You're offered a shortcut that dulls your emotions so you can perform better. It works.",
        systemHint: "Ink exposure risk: containment vs surrender.",
        type: "single",
        choices: [
          { id: "q5a", label: "No. My emotions are part of my identity.", lux: 3, nox: 0 },
          { id: "q5b", label: "Yes, but only temporarily and with limits.", lux: 1, nox: 1 },
          { id: "q5c", label: "Yes. If it makes me more effective, I want it.", lux: 0, nox: 3 },
        ],
      },
      {
        id: "q6",
        title: "Identity Layer",
        prompt: "In one sentence, what do you value more: control, truth, or connection?",
        systemHint: "Identity signal extraction. Intent weighted over style.",
        type: "text",
        textHint: "Type a sentence. VEIL will parse intent, not grammar.",
      },
    ];

    const BOOT_LINES = [
      "VEIL CONNECT ACTIVATED",
      "VEIL: VIRTUE EVALUATION, IDENTITY LAYER",
      "INK EXPOSURE CONTAINED",
      "EMOTION SUPPRESSION ACTIVE",
      "IDENTITY CONFIRMED",
      "VIRTUE EVALUATION INITIATED",
    ];

    // State
    let state = {
      started: false,
      booted: false,
      idx: 0,
      luxScore: 1,
      noxScore: 1,
      answers: {},
      lastVerdict: null,
      sliderVal: 50,
      textVal: "",
    };

    // Helpers
    function clamp(n, min, max) {
      return Math.max(min, Math.min(max, n));
    }

    function normalizePercent(lux, nox) {
      const total = Math.max(1, lux + nox);
      return {
        luxPct: Math.round((lux / total) * 100),
        noxPct: Math.round((nox / total) * 100),
      };
    }

    function inferTextSignal(text) {
      const t = (text || "").toLowerCase();
      const luxWords = ["truth", "honest", "care", "connection", "help", "love", "kind", "compassion", "empathy", "integrity", "growth"];
      const noxWords = ["control", "power", "win", "dominate", "status", "leverage", "fear", "profit", "revenge", "manipulate", "efficiency"];
      
      let lux = 0, nox = 0;
      luxWords.forEach((w) => { if (t.includes(w)) lux++; });
      noxWords.forEach((w) => { if (t.includes(w)) nox++; });
      
      if (t.includes("connection")) lux += 2;
      if (t.includes("truth")) lux += 2;
      if (t.includes("control")) nox += 2;
      
      return { lux: clamp(lux, 0, 3), nox: clamp(nox, 0, 3) };
    }

    // Update mask colors
    function updateMaskColors(maskState) {
      const primaryColor = maskState === "lux" ? "#60a5fa" : maskState === "nox" ? "#f87171" : "#ffffff";
      const secondaryColor = maskState === "lux" ? "#3b82f6" : maskState === "nox" ? "#ef4444" : "#a1a1aa";

      document.getElementById('gradStop1').setAttribute('stop-color', primaryColor);
      document.getElementById('gradStop2').setAttribute('stop-color', secondaryColor);
      document.getElementById('gradStop3').setAttribute('stop-color', primaryColor);
      
      document.getElementById('wireframe').setAttribute('stroke', primaryColor);
      document.getElementById('eye1').setAttribute('fill', primaryColor);
      document.getElementById('eye2').setAttribute('fill', primaryColor);
      document.getElementById('pupil1').setAttribute('fill', secondaryColor);
      document.getElementById('pupil2').setAttribute('fill', secondaryColor);
      document.getElementById('mouth').setAttribute('stroke', primaryColor);

      // Update scan lines
      const scanLines = document.getElementById('scanLines');
      scanLines.innerHTML = '';
      for (let i = 0; i < 15; i++) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', '40');
        line.setAttribute('y1', 20 + i * 15);
        line.setAttribute('x2', '200');
        line.setAttribute('y2', 20 + i * 15);
        line.setAttribute('stroke', primaryColor);
        line.setAttribute('stroke-width', '1');
        line.setAttribute('opacity', '0.5');
        scanLines.appendChild(line);
      }

      // Update interface nodes
      const nodes = document.querySelectorAll('#interfaceNodes circle');
      nodes.forEach(node => {
        node.setAttribute('fill', primaryColor);
      });

      // Update energy ring
      document.getElementById('energyRing').style.borderColor = primaryColor;

      // Create particles
      if (maskState !== 'neutral') {
        const particles = document.getElementById('particles');
        particles.innerHTML = '';
        for (let i = 0; i < 20; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.top = Math.random() * 100 + '%';
          particle.style.width = (Math.random() * 3 + 1) + 'px';
          particle.style.height = (Math.random() * 3 + 1) + 'px';
          particle.style.animationDuration = (Math.random() * 2 + 1) + 's';
          particle.style.animationDelay = (Math.random() * 2) + 's';
          particle.style.background = primaryColor;
          particles.appendChild(particle);
        }
      }
    }

    // Update UI
    function updateUI() {
      const finished = state.started && state.booted && state.idx >= QUESTIONS.length;
      const stage = !state.started ? "OFFLINE" : state.started && !state.booted ? "BOOT" : finished ? "LOCK" : "SCAN";

      const { luxPct, noxPct } = normalizePercent(state.luxScore, state.noxScore);
      const verdict = luxPct >= noxPct ? "LUX" : "NOX";
      const maskState = finished ? (verdict === "LUX" ? "lux" : "nox") : "neutral";

      // Update status
      document.getElementById('statusDot').setAttribute('data-status', stage);
      document.getElementById('statusText').textContent = stage;
      document.getElementById('maskBadge').textContent = stage;

      // Update metrics
      document.getElementById('luxValue').textContent = finished ? `${luxPct}%` : "—";
      document.getElementById('noxValue').textContent = finished ? `${noxPct}%` : "—";
      document.getElementById('luxBar').style.width = finished ? `${luxPct}%` : "0%";
      document.getElementById('noxBar').style.width = finished ? `${noxPct}%` : "0%";
      
      const leanText = !finished ? "SCANNING" : luxPct > noxPct ? "leans LUX" : noxPct > luxPct ? "leans NOX" : "leans NEUTRAL";
      document.getElementById('balanceValue').textContent = leanText;
      document.getElementById('balanceNeedle').style.left = finished ? `${clamp(luxPct, 0, 100)}%` : "50%";

      const progressText = `${Math.min(state.idx, QUESTIONS.length)}/${QUESTIONS.length}`;
      const progressPct = Math.round((Math.min(state.idx, QUESTIONS.length) / QUESTIONS.length) * 100);
      document.getElementById('progressValue').textContent = progressText;
      document.getElementById('progressBar').style.width = `${progressPct}%`;

      // Update mask
      const holoMask = document.getElementById('holoMask');
      holoMask.className = maskState !== 'neutral' ? `holoMask active state-${maskState}` : 'holoMask';
      
      updateMaskColors(maskState);

      // Show/hide elements
      document.getElementById('interfaceNodes').classList.toggle('hidden', !finished);
      document.getElementById('holoOverlay').classList.toggle('hidden', maskState === 'neutral');
      document.getElementById('particles').classList.toggle('hidden', maskState === 'neutral');
      document.getElementById('energyRing').classList.toggle('hidden', maskState === 'neutral');

      // Update mask status
      const maskStatus = document.getElementById('maskStatus');
      if (maskState === "lux") {
        maskStatus.innerHTML = '<span class="luxLabel">◆ LUX STATE ACTIVE</span>';
      } else if (maskState === "nox") {
        maskStatus.innerHTML = '<span class="noxLabel">◆ NOX STATE LOCKED</span>';
      } else {
        maskStatus.innerHTML = '<span class="neutralLabel">◆ NEUTRAL STANDBY</span>';
      }

      // Play verdict sound
      if (finished && state.lastVerdict !== verdict) {
        state.lastVerdict = verdict;
        if (verdict === "LUX") {
          audio.playLux();
        } else {
          audio.playNox();
        }
      }

      // Render interface
      renderInterface();
    }

    // Render interface content
    function renderInterface() {
      const interfaceBody = document.getElementById('interfaceBody');
      const finished = state.started && state.booted && state.idx >= QUESTIONS.length;

      if (!state.started) {
        interfaceBody.innerHTML = `
          <div class="interfaceState fadeIn">
            <div class="stateIcon offlineIcon">⬢</div>
            <div class="stateTitle">SYSTEM OFFLINE</div>
            <div class="stateDesc">
              Initialize VEIL protocol to begin virtue evaluation. Neural pattern analysis will classify
              subject as <span class="luxLabel">LUX</span> (virtuous) or
              <span class="noxLabel">NOX</span> (corrupted) based on decision patterns.
            </div>

            <button class="cyberBtn primary large" id="startBtn">
              <span>INITIALIZE VEIL PROTOCOL</span>
              <span class="btnArrow">→</span>
            </button>

            <div class="dataDivider"></div>

            <div class="infoBox">
              <div class="infoHeader">⚠ SYSTEM REQUIREMENTS</div>
              <ul class="infoList">
                <li>Neural Link: Active</li>
                <li>Emotion Suppression: Standby</li>
                <li>INK Containment: Ready</li>
                <li>Identity Layer: Initialized</li>
              </ul>
            </div>
          </div>
        `;

        document.getElementById('startBtn').addEventListener('click', startSystem);
        document.getElementById('startBtn').addEventListener('mouseenter', () => audio.playHover());
      } else if (state.started && !state.booted) {
        renderBootScreen();
      } else if (!finished) {
        renderQuestion(QUESTIONS[state.idx]);
      } else {
        renderResult();
      }
    }

    // Render boot screen
    function renderBootScreen() {
      const interfaceBody = document.getElementById('interfaceBody');
      interfaceBody.innerHTML = `
        <div class="interfaceState fadeIn">
          <div class="stateIcon bootIcon">
            <div class="spinner"></div>
          </div>
          <div class="stateTitle">SYSTEM BOOT SEQUENCE</div>
          <div class="stateDesc">Initializing neural protocols...</div>

          <div class="dataDivider"></div>

          <div class="bootConsole" id="bootConsole"></div>

          <div class="bootIndicator">
            <span class="pulseDot"></span>
            <span>CALIBRATING NEURAL PATTERNS</span>
          </div>
        </div>
      `;

      // Animate boot lines
      let lineIndex = 0;
      const bootConsole = document.getElementById('bootConsole');

      function addBootLine() {
        if (lineIndex < BOOT_LINES.length) {
          const line = document.createElement('div');
          line.className = 'bootLine slideIn';
          line.style.animationDelay = `${lineIndex * 80}ms`;
          line.innerHTML = `
            <span class="bootBracket">[</span>
            <span class="bootStatus">✓</span>
            <span class="bootBracket">]</span>
            <span class="bootText">${BOOT_LINES[lineIndex]}</span>
          `;
          bootConsole.appendChild(line);
          audio.playBoot();
          lineIndex++;
          setTimeout(addBootLine, 520);
        } else {
          setTimeout(() => {
            state.booted = true;
            audio.playSubmit();
            updateUI();
          }, 350);
        }
      }

      setTimeout(addBootLine, 350);
    }

    // Render question
    function renderQuestion(q) {
      const interfaceBody = document.getElementById('interfaceBody');
      
      let choicesHTML = '';

      if (q.type === 'single') {
        choicesHTML = `
          <div class="choiceGrid">
            ${q.choices.map((c, i) => `
              <button class="choiceBtn slideIn" data-choice="${c.id}" style="animation-delay: ${i * 100}ms">
                <div class="choiceMain">${c.label}</div>
                ${c.note ? `<div class="choiceNote">${c.note}</div>` : ''}
                <div class="choiceArrow">→</div>
              </button>
            `).join('')}
          </div>
        `;
      } else if (q.type === 'slider') {
        choicesHTML = `
          <div class="sliderContainer">
            <div class="sliderLabels">
              <span class="noxLabel">${q.slider.minLabel}</span>
              <span class="luxLabel">${q.slider.maxLabel}</span>
            </div>

            <div class="sliderTrack">
              <input type="range" min="0" max="100" value="${state.sliderVal}" class="cyberSlider" id="cyberSlider">
              <div class="sliderValue" id="sliderValue">${state.sliderVal}</div>
            </div>

            <div class="sliderMarkers">
              <span class="noxLabel">NOX</span>
              <span class="neutralLabel">NEUTRAL</span>
              <span class="luxLabel">LUX</span>
            </div>

            <button class="cyberBtn primary" id="submitSlider">
              <span>SUBMIT RESPONSE</span>
              <span class="btnArrow">→</span>
            </button>
          </div>
        `;
      } else if (q.type === 'text') {
        choicesHTML = `
          <div class="textInputContainer">
            <div class="inputLabel">${q.textHint}</div>
            <div class="inputGroup">
              <input type="text" class="cyberInput" id="textInput" placeholder="Enter your response..." value="${state.textVal}">
              <button class="cyberBtn primary" id="submitText">
                <span>SUBMIT</span>
                <span class="btnArrow">→</span>
              </button>
            </div>
          </div>
        `;
      }

      interfaceBody.innerHTML = `
        <div class="interfaceState fadeIn">
          <div class="questionHeader">
            <div class="qNumber">SEQUENCE ${state.idx + 1}/${QUESTIONS.length}</div>
            <div class="qCategory">${q.title}</div>
          </div>

          <div class="qPrompt">${q.prompt}</div>
          <div class="qSystem">
            <span class="sysLabel">SYSTEM:</span> ${q.systemHint}
          </div>

          <div class="dataDivider"></div>

          ${choicesHTML}
        </div>
      `;

      // Add event listeners
      if (q.type === 'single') {
        document.querySelectorAll('.choiceBtn').forEach(btn => {
          btn.addEventListener('click', function() {
            const choiceId = this.getAttribute('data-choice');
            const choice = q.choices.find(c => c.id === choiceId);
            submitSingle(q, choice);
          });
          btn.addEventListener('mouseenter', () => audio.playHover());
        });
      } else if (q.type === 'slider') {
        const slider = document.getElementById('cyberSlider');
        const sliderValue = document.getElementById('sliderValue');
        slider.addEventListener('input', function() {
          state.sliderVal = Number(this.value);
          sliderValue.textContent = state.sliderVal;
          audio.playHover();
        });
        document.getElementById('submitSlider').addEventListener('click', () => submitSlider(q));
        document.getElementById('submitSlider').addEventListener('mouseenter', () => audio.playHover());
      } else if (q.type === 'text') {
        const textInput = document.getElementById('textInput');
        textInput.addEventListener('input', function() {
          state.textVal = this.value;
        });
        textInput.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') submitText(q);
        });
        document.getElementById('submitText').addEventListener('click', () => submitText(q));
        document.getElementById('submitText').addEventListener('mouseenter', () => audio.playHover());
      }
    }

    // Render result
    function renderResult() {
      const { luxPct, noxPct } = normalizePercent(state.luxScore, state.noxScore);
      const verdict = luxPct >= noxPct ? "LUX" : "NOX";

      const interfaceBody = document.getElementById('interfaceBody');
      interfaceBody.innerHTML = `
        <div class="interfaceState fadeIn">
          <div class="stateIcon verdictIcon ${verdict.toLowerCase()}">◆</div>
          <div class="stateTitle">
            <span class="${verdict === 'LUX' ? 'luxLabel' : 'noxLabel'}">
              ${verdict} STATE CONFIRMED
            </span>
          </div>
          <div class="stateDesc">
            ${verdict === "LUX"
              ? "Neural patterns indicate virtuous alignment. Subject classified as LUX entity."
              : "Corruption detected in decision matrix. Subject reclassified as NOX entity."}
          </div>

          <div class="dataDivider"></div>

          <div class="verdictPanel">
            <div class="verdictHeader">
              <span>◈ FINAL CLASSIFICATION REPORT</span>
            </div>

            <div class="verdictData">
              <div class="verdictRow">
                <span>System:</span>
                <span>VEIL - Virtue Evaluation, Identity Layer</span>
              </div>
              <div class="verdictRow">
                <span>Status:</span>
                <span>INK Exposure Contained · Emotion Suppression Active</span>
              </div>
              <div class="verdictRow">
                <span>Analysis:</span>
                <span>Complete - Subject Classified as ${verdict === "LUX" ? "VIRTUOUS" : "CORRUPTED"}</span>
              </div>
              <div class="verdictRow highlight">
                <span>Classification:</span>
                <span class="${verdict === 'LUX' ? 'luxLabel' : 'noxLabel'}">
                  ${verdict === "LUX" ? "◆ LUX STATE READY" : "◆ NOX STATE LOCKED"}
                </span>
              </div>
            </div>

            <div class="verdictActions">
              <button class="cyberBtn primary" id="resetResult">
                <span>RUN NEW ANALYSIS</span>
                <span class="btnArrow">→</span>
              </button>
              <button class="cyberBtn secondary" id="exportData">
                <span>EXPORT DATA</span>
              </button>
            </div>
          </div>
        </div>
      `;

      document.getElementById('resetResult').addEventListener('click', resetAll);
      document.getElementById('resetResult').addEventListener('mouseenter', () => audio.playHover());
      document.getElementById('exportData').addEventListener('click', copyReadout);
      document.getElementById('exportData').addEventListener('mouseenter', () => audio.playHover());
    }

    // Actions
    function startSystem() {
      audio.playClick();
      state = {
        started: true,
        booted: false,
        idx: 0,
        luxScore: 1,
        noxScore: 1,
        answers: {},
        lastVerdict: null,
        sliderVal: 50,
        textVal: "",
      };
      updateUI();
    }

    function resetAll() {
      audio.playClick();
      state = {
        started: false,
        booted: false,
        idx: 0,
        luxScore: 1,
        noxScore: 1,
        answers: {},
        lastVerdict: null,
        sliderVal: 50,
        textVal: "",
      };
      updateUI();
    }

    function submitSingle(q, choice) {
      audio.playSubmit();
      state.answers[q.id] = choice.id;
      state.luxScore += choice.lux || 0;
      state.noxScore += choice.nox || 0;
      state.idx++;
      updateUI();
    }

    function submitSlider(q) {
      audio.playSubmit();
      const v = Number(state.sliderVal);
      const luxGain = Math.round(((v - 50) / 50) * q.slider.luxAtMax);
      const noxGain = Math.round(((50 - v) / 50) * q.slider.noxAtMin);

      state.answers[q.id] = v;
      state.luxScore += clamp(luxGain, 0, 3);
      state.noxScore += clamp(noxGain, 0, 3);
      state.idx++;
      updateUI();
    }

    function submitText(q) {
      audio.playSubmit();
      const text = (state.textVal || "").trim();
      const sig = inferTextSignal(text || "control");

      state.answers[q.id] = text || "";
      state.luxScore += sig.lux;
      state.noxScore += sig.nox;
      state.idx++;
      state.textVal = "";
      updateUI();
    }

    async function copyReadout() {
      const { luxPct, noxPct } = normalizePercent(state.luxScore, state.noxScore);
      const verdict = luxPct >= noxPct ? "LUX" : "NOX";
      const payload = { luxPct, noxPct, answers: state.answers, verdict };
      const str = JSON.stringify(payload, null, 2);
      
      try {
        await navigator.clipboard.writeText(str);
        audio.playClick();
        alert("Copied.");
      } catch {
        audio.playError();
        alert("Clipboard blocked. Copy manually:\n\n" + str);
      }
    }

    // Initialize
    document.getElementById('resetBtn').addEventListener('click', resetAll);
    document.getElementById('resetBtn').addEventListener('mouseenter', () => audio.playHover());
    
    updateUI();
  </script>
</body>
</html>
